(ns sbocq.cronit-test
  (:require [clojure.test :as t :refer [is deftest testing]]
            [sbocq.cronit :as c])
  (:import [java.time Duration ZonedDateTime ZoneId]
           [java.time.temporal ChronoUnit]))


;;;
;;; Lazy man's property tests
;;;

(defn pick-start-date
  "Pick a random start date in a range defined by a vector of aligned dates."
  [results]
  (let [len (count results)
        min-date-idx (int (rand len))
        min-date (results min-date-idx)
        max-date-idx (+ min-date-idx (int (rand (- len min-date-idx))))
        max-date (results max-date-idx)]
    (case (int (rand 4))
      0 {:start-date min-date
         :valid? true}
      1 {:start-date max-date
         :valid? true}
      (2 3) (let [date (.addTo ChronoUnit/SECONDS
                               min-date
                               (int (/ (.getSeconds
                                        (Duration/between min-date max-date))
                                       2)))]
              {:start-date  date
               :valid? (boolean (some #{date} results))}))))

(comment
  (pick-start-date (mapv (fn [d] (ZonedDateTime/parse d))
                         ["2021-09-15T02:10+10:30[Australia/Lord_Howe]"
                          "2021-09-16T02:10+10:30[Australia/Lord_Howe]"
                          "2021-09-17T02:10+10:30[Australia/Lord_Howe]"
                          "2021-09-18T02:10+10:30[Australia/Lord_Howe]"]))
  )

(defn iter [direction cronit]
  (->> cronit
       (iterate direction)
       (map :current)))

(defn iter-props [n c-expr results]
  (letfn [(all-results-match [cronit dir-key]
            ;; Test that, given a cronit object, all steps forward or backward are
            ;; consistent with the result.
            (let [min-date (first results)
                  max-date (last results)
                  start-date (:current cronit)
                  gen-dates (vec
                             (take-while
                              (if (= dir-key :forward)
                                (fn [date] (not (.isAfter date max-date)))
                                (fn [date] (not (.isBefore date min-date))))
                              ;; protect against infinite recursion bugs
                              (let [points (take 200 (iter (if (= dir-key :forward)
                                                             c/next
                                                             c/prev)
                                                           cronit))]
                                (if (c/valid? cronit) points (rest points)))))
                  ref-dates (vec
                             (if (= dir-key :forward)
                               (drop-while (fn [date] (.isBefore date start-date))
                                           results)
                               (reverse
                                (take-while (fn [date]
                                              (not (.isAfter date start-date)))
                                            results))))]
              (when-not (= gen-dates ref-dates)
                {:error [:range-mismatch {:dir-key dir-key
                                          :c-expr c-expr
                                          :start-date (str start-date)
                                          :ref-dates (map str ref-dates)
                                          :gen-dates (map str gen-dates)}]})))]
    ;; Pick a random date and check props.
    (let [{:keys [:start-date :valid?]} (pick-start-date results)
          cronit (c/init c-expr start-date)]
      ;; 1. If start date is valid then the initial iterator must be valid
      (if (not= (boolean valid?) (c/valid? cronit))
        {:error [:init-valid-mismatch {:c-expr c-expr
                                       :start-date start-date
                                       :start-date-valid? (boolean valid?)
                                       :init-valid? (c/valid? cronit)
                                       :unaligned? (:unaligned? cronit)
                                       :unaligned-cause (:unaligned-cause cronit)}]}
        ;; 2. If from that random date, we travel forward or backward, generated dates
        ;; must be consistent with the expected result.
        (let [error (or (all-results-match cronit :forward)
                        (all-results-match cronit :backward))]
          ;; Rince and repeat for as long as there is no error.
          (if (or (= 0 n) error) error
              (recur (dec n) c-expr results)))))))


;;;
;;; Tests
;;;

;; Reference results generated by c/show and validated manually using a calendar.
(def tests [{:title "2h10 on 2021-10-03 does not exist (1)"
             :c-expr {:minute 10, :hour 2}
             :results  ["2021-09-15T02:10+10:30[Australia/Lord_Howe]"
                        "2021-09-16T02:10+10:30[Australia/Lord_Howe]"
                        "2021-09-17T02:10+10:30[Australia/Lord_Howe]"
                        "2021-09-18T02:10+10:30[Australia/Lord_Howe]"
                        "2021-09-19T02:10+10:30[Australia/Lord_Howe]"
                        "2021-09-20T02:10+10:30[Australia/Lord_Howe]"
                        "2021-09-21T02:10+10:30[Australia/Lord_Howe]"
                        "2021-09-22T02:10+10:30[Australia/Lord_Howe]"
                        "2021-09-23T02:10+10:30[Australia/Lord_Howe]"
                        "2021-09-24T02:10+10:30[Australia/Lord_Howe]"
                        "2021-09-25T02:10+10:30[Australia/Lord_Howe]"
                        "2021-09-26T02:10+10:30[Australia/Lord_Howe]"
                        "2021-09-27T02:10+10:30[Australia/Lord_Howe]"
                        "2021-09-28T02:10+10:30[Australia/Lord_Howe]"
                        "2021-09-29T02:10+10:30[Australia/Lord_Howe]"
                        "2021-09-30T02:10+10:30[Australia/Lord_Howe]"
                        "2021-10-01T02:10+10:30[Australia/Lord_Howe]"
                        "2021-10-02T02:10+10:30[Australia/Lord_Howe]"
                        "2021-10-03T02:30+11:00[Australia/Lord_Howe]" ;after gap
                        "2021-10-04T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-05T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-06T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-07T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-08T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-09T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-10T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-11T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-12T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-13T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-14T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-15T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-16T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-17T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-18T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-19T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-20T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-21T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-22T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-23T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-24T02:10+11:00[Australia/Lord_Howe]"]}
            {:title "2h10 on 2021-10-03 does not exist (2)"
             :c-expr {:minute 10, :hour 2, :day-of-month [3 10],
                      :month [:* 2 12 2]}
             :results ["2020-02-03T02:10+11:00[Australia/Lord_Howe]"
                       "2020-02-10T02:10+11:00[Australia/Lord_Howe]"
                       "2020-04-03T02:10+11:00[Australia/Lord_Howe]"
                       "2020-04-10T02:10+10:30[Australia/Lord_Howe]"
                       "2020-06-03T02:10+10:30[Australia/Lord_Howe]"
                       "2020-06-10T02:10+10:30[Australia/Lord_Howe]"
                       "2020-08-03T02:10+10:30[Australia/Lord_Howe]"
                       "2020-08-10T02:10+10:30[Australia/Lord_Howe]"
                       "2020-10-03T02:10+10:30[Australia/Lord_Howe]"
                       "2020-10-10T02:10+11:00[Australia/Lord_Howe]"
                       "2020-12-03T02:10+11:00[Australia/Lord_Howe]"
                       "2020-12-10T02:10+11:00[Australia/Lord_Howe]"
                       "2021-02-03T02:10+11:00[Australia/Lord_Howe]"
                       "2021-02-10T02:10+11:00[Australia/Lord_Howe]"
                       "2021-04-03T02:10+11:00[Australia/Lord_Howe]"
                       "2021-04-10T02:10+10:30[Australia/Lord_Howe]"
                       "2021-06-03T02:10+10:30[Australia/Lord_Howe]"
                       "2021-06-10T02:10+10:30[Australia/Lord_Howe]"
                       "2021-08-03T02:10+10:30[Australia/Lord_Howe]"
                       "2021-08-10T02:10+10:30[Australia/Lord_Howe]"
                       "2021-10-03T02:30+11:00[Australia/Lord_Howe]" ;after gap
                       "2021-10-10T02:10+11:00[Australia/Lord_Howe]"
                       "2021-12-03T02:10+11:00[Australia/Lord_Howe]"
                       "2021-12-10T02:10+11:00[Australia/Lord_Howe]"
                       "2022-02-03T02:10+11:00[Australia/Lord_Howe]"
                       "2022-02-10T02:10+11:00[Australia/Lord_Howe]"
                       "2022-04-03T02:10+10:30[Australia/Lord_Howe]"
                       "2022-04-10T02:10+10:30[Australia/Lord_Howe]"
                       "2022-06-03T02:10+10:30[Australia/Lord_Howe]"
                       "2022-06-10T02:10+10:30[Australia/Lord_Howe]"
                       "2022-08-03T02:10+10:30[Australia/Lord_Howe]"
                       "2022-08-10T02:10+10:30[Australia/Lord_Howe]"
                       "2022-10-03T02:10+11:00[Australia/Lord_Howe]"
                       "2022-10-10T02:10+11:00[Australia/Lord_Howe]"
                       "2022-12-03T02:10+11:00[Australia/Lord_Howe]"
                       "2022-12-10T02:10+11:00[Australia/Lord_Howe]"
                       "2023-02-03T02:10+11:00[Australia/Lord_Howe]"
                       "2023-02-10T02:10+11:00[Australia/Lord_Howe]"
                       "2023-04-03T02:10+10:30[Australia/Lord_Howe]"
                       "2023-04-10T02:10+10:30[Australia/Lord_Howe]"]}
            {:title "2h10 on 2021-10-03 does not exist (2)"
             :c-expr {:minute 10, :hour 2, :day-of-week [1 7],
                      :week-of-month [:+ [:* 1]],
                      :month [:+ 3 5 10],
                      :week-fields :iso}
             :results  ["2020-05-11T02:10+10:30[Australia/Lord_Howe]"
                        "2020-05-17T02:10+10:30[Australia/Lord_Howe]"
                        "2020-05-18T02:10+10:30[Australia/Lord_Howe]"
                        "2020-05-24T02:10+10:30[Australia/Lord_Howe]"
                        "2020-05-25T02:10+10:30[Australia/Lord_Howe]"
                        "2020-05-31T02:10+10:30[Australia/Lord_Howe]"
                        "2020-10-04T02:30+11:00[Australia/Lord_Howe]" ;after gap
                        "2020-10-05T02:10+11:00[Australia/Lord_Howe]"
                        "2020-10-11T02:10+11:00[Australia/Lord_Howe]"
                        "2020-10-12T02:10+11:00[Australia/Lord_Howe]"
                        "2020-10-18T02:10+11:00[Australia/Lord_Howe]"
                        "2020-10-19T02:10+11:00[Australia/Lord_Howe]"
                        "2020-10-25T02:10+11:00[Australia/Lord_Howe]"
                        "2020-10-26T02:10+11:00[Australia/Lord_Howe]"
                        "2021-03-01T02:10+11:00[Australia/Lord_Howe]"
                        "2021-03-07T02:10+11:00[Australia/Lord_Howe]"
                        "2021-03-08T02:10+11:00[Australia/Lord_Howe]"
                        "2021-03-14T02:10+11:00[Australia/Lord_Howe]"
                        "2021-03-15T02:10+11:00[Australia/Lord_Howe]"
                        "2021-03-21T02:10+11:00[Australia/Lord_Howe]"
                        "2021-03-22T02:10+11:00[Australia/Lord_Howe]"
                        "2021-03-28T02:10+11:00[Australia/Lord_Howe]"
                        "2021-03-29T02:10+11:00[Australia/Lord_Howe]"
                        "2021-05-02T02:10+10:30[Australia/Lord_Howe]"
                        "2021-05-03T02:10+10:30[Australia/Lord_Howe]"
                        "2021-05-09T02:10+10:30[Australia/Lord_Howe]"
                        "2021-05-10T02:10+10:30[Australia/Lord_Howe]"
                        "2021-05-16T02:10+10:30[Australia/Lord_Howe]"
                        "2021-05-17T02:10+10:30[Australia/Lord_Howe]"
                        "2021-05-23T02:10+10:30[Australia/Lord_Howe]"
                        "2021-05-24T02:10+10:30[Australia/Lord_Howe]"
                        "2021-05-30T02:10+10:30[Australia/Lord_Howe]"
                        "2021-05-31T02:10+10:30[Australia/Lord_Howe]"
                        "2021-10-03T02:30+11:00[Australia/Lord_Howe]" ;after gap
                        "2021-10-04T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-10T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-11T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-17T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-18T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-24T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-25T02:10+11:00[Australia/Lord_Howe]"
                        "2021-10-31T02:10+11:00[Australia/Lord_Howe]"
                        "2022-03-06T02:10+11:00[Australia/Lord_Howe]"
                        "2022-03-07T02:10+11:00[Australia/Lord_Howe]"
                        "2022-03-13T02:10+11:00[Australia/Lord_Howe]"
                        "2022-03-14T02:10+11:00[Australia/Lord_Howe]"
                        "2022-03-20T02:10+11:00[Australia/Lord_Howe]"
                        "2022-03-21T02:10+11:00[Australia/Lord_Howe]"]}
            {:title "Skip months that do not have a 31st day"
             :c-expr {:day-of-month 31}
             :results ["2020-05-31T00:00+10:30[Australia/Lord_Howe]"
                       "2020-07-31T00:00+10:30[Australia/Lord_Howe]"
                       "2020-08-31T00:00+10:30[Australia/Lord_Howe]"
                       "2020-10-31T00:00+11:00[Australia/Lord_Howe]"
                       "2020-12-31T00:00+11:00[Australia/Lord_Howe]"
                       "2021-01-31T00:00+11:00[Australia/Lord_Howe]"
                       "2021-03-31T00:00+11:00[Australia/Lord_Howe]"
                       "2021-05-31T00:00+10:30[Australia/Lord_Howe]"
                       "2021-07-31T00:00+10:30[Australia/Lord_Howe]"
                       "2021-08-31T00:00+10:30[Australia/Lord_Howe]"
                       "2021-10-31T00:00+11:00[Australia/Lord_Howe]"
                       "2021-12-31T00:00+11:00[Australia/Lord_Howe]"
                       "2022-01-31T00:00+11:00[Australia/Lord_Howe]"]}
            {:title "Last day of the month"
             :c-expr {:day-of-month -1}
             :results ["2020-01-31T00:00+11:00[Australia/Lord_Howe]"
                       "2020-02-29T00:00+11:00[Australia/Lord_Howe]"
                       "2020-03-31T00:00+11:00[Australia/Lord_Howe]"
                       "2020-04-30T00:00+10:30[Australia/Lord_Howe]"
                       "2020-05-31T00:00+10:30[Australia/Lord_Howe]"
                       "2020-06-30T00:00+10:30[Australia/Lord_Howe]"
                       "2020-07-31T00:00+10:30[Australia/Lord_Howe]"
                       "2020-08-31T00:00+10:30[Australia/Lord_Howe]"
                       "2020-09-30T00:00+10:30[Australia/Lord_Howe]"
                       "2020-10-31T00:00+11:00[Australia/Lord_Howe]"
                       "2020-11-30T00:00+11:00[Australia/Lord_Howe]"
                       "2020-12-31T00:00+11:00[Australia/Lord_Howe]"
                       "2021-01-31T00:00+11:00[Australia/Lord_Howe]"
                       "2021-02-28T00:00+11:00[Australia/Lord_Howe]"]}
            {:title "Every second and last Thursday and Sunday of the month, at 2 am"
             :c-expr {:hour 2, :day-of-week [:+ :thu :sun],
                      :day-of-month [:+ [:* 8 14] [:* -7 -1 1]],
                      :week-fields :iso}
             :results ["2021-01-10T02:00+01:00[Europe/Brussels]"
                       "2021-01-14T02:00+01:00[Europe/Brussels]"
                       "2021-01-28T02:00+01:00[Europe/Brussels]"
                       "2021-01-31T02:00+01:00[Europe/Brussels]"
                       "2021-02-11T02:00+01:00[Europe/Brussels]"
                       "2021-02-14T02:00+01:00[Europe/Brussels]"
                       "2021-02-25T02:00+01:00[Europe/Brussels]"
                       "2021-02-28T02:00+01:00[Europe/Brussels]"
                       "2021-03-11T02:00+01:00[Europe/Brussels]"
                       "2021-03-14T02:00+01:00[Europe/Brussels]"
                       "2021-03-25T02:00+01:00[Europe/Brussels]"
                       "2021-03-28T03:00+02:00[Europe/Brussels]" ;after gap
                       "2021-04-08T02:00+02:00[Europe/Brussels]"
                       "2021-04-11T02:00+02:00[Europe/Brussels]"
                       "2021-04-25T02:00+02:00[Europe/Brussels]"
                       "2021-04-29T02:00+02:00[Europe/Brussels]"
                       "2021-05-09T02:00+02:00[Europe/Brussels]"
                       "2021-05-13T02:00+02:00[Europe/Brussels]"
                       "2021-05-27T02:00+02:00[Europe/Brussels]"
                       "2021-05-30T02:00+02:00[Europe/Brussels]"
                       "2021-06-10T02:00+02:00[Europe/Brussels]"
                       "2021-06-13T02:00+02:00[Europe/Brussels]"
                       "2021-06-24T02:00+02:00[Europe/Brussels]"
                       "2021-06-27T02:00+02:00[Europe/Brussels]"
                       "2021-07-08T02:00+02:00[Europe/Brussels]"
                       "2021-07-11T02:00+02:00[Europe/Brussels]"
                       "2021-07-25T02:00+02:00[Europe/Brussels]"
                       "2021-07-29T02:00+02:00[Europe/Brussels]"
                       "2021-08-08T02:00+02:00[Europe/Brussels]"
                       "2021-08-12T02:00+02:00[Europe/Brussels]"]}
            {:title "Every Sunday on week 0, :iso"
             :c-expr {:day-of-week :sun, :week-of-month 0, :week-fields :iso}
             :results ["2021-01-03T00:00+01:00[Europe/Brussels]"
                       "2021-05-02T00:00+02:00[Europe/Brussels]"
                       "2021-08-01T00:00+02:00[Europe/Brussels]"
                       "2021-10-03T00:00+02:00[Europe/Brussels]"
                       "2022-01-02T00:00+01:00[Europe/Brussels]"
                       "2022-04-03T00:00+02:00[Europe/Brussels]"
                       "2022-05-01T00:00+02:00[Europe/Brussels]"
                       "2022-07-03T00:00+02:00[Europe/Brussels]"
                       "2022-10-02T00:00+02:00[Europe/Brussels]"]}
            {:title "Every Sunday of week 1 of the month, :iso"
             :c-expr {:day-of-week :sun, :week-of-month 1, :week-fields :iso}
             :results ["2021-01-10T00:00+01:00[Europe/Brussels]"
                       "2021-02-07T00:00+01:00[Europe/Brussels]"
                       "2021-03-07T00:00+01:00[Europe/Brussels]"
                       "2021-04-04T00:00+02:00[Europe/Brussels]"
                       "2021-05-09T00:00+02:00[Europe/Brussels]"
                       "2021-06-06T00:00+02:00[Europe/Brussels]"
                       "2021-07-04T00:00+02:00[Europe/Brussels]"
                       "2021-08-08T00:00+02:00[Europe/Brussels]"
                       "2021-09-05T00:00+02:00[Europe/Brussels]"
                       "2021-10-10T00:00+02:00[Europe/Brussels]"
                       "2021-11-07T00:00+01:00[Europe/Brussels]"
                       "2021-12-05T00:00+01:00[Europe/Brussels]"]}
            {:title "Every Sunday of the first week of the month, :iso"
             :c-expr {:day-of-week :sun, :week-of-month :+, :week-fields :iso}
             :results ["2021-01-03T00:00+01:00[Europe/Brussels]"
                       "2021-02-07T00:00+01:00[Europe/Brussels]"
                       "2021-03-07T00:00+01:00[Europe/Brussels]"
                       "2021-04-04T00:00+02:00[Europe/Brussels]"
                       "2021-05-02T00:00+02:00[Europe/Brussels]"
                       "2021-06-06T00:00+02:00[Europe/Brussels]"
                       "2021-07-04T00:00+02:00[Europe/Brussels]"
                       "2021-08-01T00:00+02:00[Europe/Brussels]"
                       "2021-09-05T00:00+02:00[Europe/Brussels]"
                       "2021-10-03T00:00+02:00[Europe/Brussels]"
                       "2021-11-07T00:00+01:00[Europe/Brussels]"
                       "2021-12-05T00:00+01:00[Europe/Brussels]"]}
            {:title "Every Monday and Sunday of the first week of the year, :iso"
             :c-expr {:day-of-week [:+ :mon :sun], :week-of-year :+, :week-fields :iso}
             :results ["2013-01-06T00:00:00+01:00[Europe/Brussels]"
                       "2014-01-05T00:00:00+01:00[Europe/Brussels]"
                       "2015-01-04T00:00:00+01:00[Europe/Brussels]"
                       "2016-01-03T00:00:00+01:00[Europe/Brussels]"
                       "2017-01-01T00:00:00+01:00[Europe/Brussels]"
                       "2018-01-01T00:00:00+01:00[Europe/Brussels]"
                       "2018-01-07T00:00:00+01:00[Europe/Brussels]"
                       "2019-01-06T00:00:00+01:00[Europe/Brussels]"
                       "2020-01-05T00:00:00+01:00[Europe/Brussels]"
                       ;;w0 but also w53 of 2020
                       "2021-01-03T00:00:00+01:00[Europe/Brussels]"
                       "2022-01-02T00:00:00+01:00[Europe/Brussels]"
                       "2023-01-01T00:00:00+01:00[Europe/Brussels]"
                       "2024-01-01T00:00:00+01:00[Europe/Brussels]"
                       "2024-01-07T00:00:00+01:00[Europe/Brussels]"
                       "2025-01-05T00:00:00+01:00[Europe/Brussels]"
                       "2026-01-04T00:00:00+01:00[Europe/Brussels]"
                       "2027-01-03T00:00:00+01:00[Europe/Brussels]"
                       "2028-01-02T00:00:00+01:00[Europe/Brussels]"
                       "2029-01-01T00:00:00+01:00[Europe/Brussels]"
                       "2029-01-07T00:00:00+01:00[Europe/Brussels]"
                       ]}
            {:title "Every Sunday of the first week of the month (locale independent)"
             :c-expr {:day-of-week :sun, :day-of-month [:* 1 7]}
             :results ["2021-01-03T00:00+01:00[Europe/Brussels]"
                       "2021-02-07T00:00+01:00[Europe/Brussels]"
                       "2021-03-07T00:00+01:00[Europe/Brussels]"
                       "2021-04-04T00:00+02:00[Europe/Brussels]"
                       "2021-05-02T00:00+02:00[Europe/Brussels]"
                       "2021-06-06T00:00+02:00[Europe/Brussels]"
                       "2021-07-04T00:00+02:00[Europe/Brussels]"
                       "2021-08-01T00:00+02:00[Europe/Brussels]"
                       "2021-09-05T00:00+02:00[Europe/Brussels]"
                       "2021-10-03T00:00+02:00[Europe/Brussels]"
                       "2021-11-07T00:00+01:00[Europe/Brussels]"
                       "2021-12-05T00:00+01:00[Europe/Brussels]"]}
            {:title "Every Monday on week 5, :iso"
             :c-expr {:week-of-month 5, :week-fields :iso}
             :results ["2021-03-29T00:00+02:00[Europe/Brussels]"
                       "2021-04-26T00:00+02:00[Europe/Brussels]"
                       "2021-05-31T00:00+02:00[Europe/Brussels]"
                       "2021-06-28T00:00+02:00[Europe/Brussels]"
                       "2021-07-26T00:00+02:00[Europe/Brussels]"
                       "2021-08-30T00:00+02:00[Europe/Brussels]"
                       "2021-09-27T00:00+02:00[Europe/Brussels]"
                       "2021-11-29T00:00+01:00[Europe/Brussels]"
                       "2021-12-27T00:00+01:00[Europe/Brussels]"]}
            ])

;; Adjust range by computing distance to gap-from. Backwards?

(comment
  ;; To generate some results.
  (c/show {:day-of-week [:+ :mon :sun], :week-of-year :+, :week-fields :iso}
          {:date "2021-08-18T12:00+02:00[Europe/Brussels]"
           :format :iso})

  ;; To run a specific test
  (let [{:keys [:c-expr :results]} (tests 0)]
    (iter-props 100 c-expr (mapv (fn [d] (ZonedDateTime/parse d))
                                 results)))
  )


(deftest prop-tests
  (t/are [my-test] (= nil (let [{:keys [:c-expr :results]} my-test
                                expected-results (mapv (fn [d] (ZonedDateTime/parse d))
                                                       results)]
                            ;; Generated cronit sequences must be monotonically increasing
                            (assert (reduce (fn [^ZonedDateTime zdt1 zdt2]
                                              (if (.isBefore zdt1 zdt2)
                                                zdt2
                                                (throw (ex-info "not-increasing"
                                                                {:ts [zdt1 zdt2]}))))
                                            (first expected-results)
                                            (rest expected-results)))
                            (iter-props 200 c-expr expected-results)))
    (tests 0)
    (tests 1)
    (tests 2)
    (tests 3)
    (tests 4)
    (tests 5)
    (tests 6)
    (tests 7)
    (tests 8)
    (tests 9)
    (tests 10)))


(deftest specific-cases
  (testing "Return datetime immediately after a gap if it is aligned"
    (is (= (ZonedDateTime/parse "2021-03-28T03:00+02:00[Europe/Brussels]")
           (->
            (c/init {:minute [:* 30]}
                    (ZonedDateTime/parse "2021-03-28T01:30:00+01:00[Europe/Brussels]"))
            c/next :current))))
  (testing "Return end of gap (1) if hour/minute within gap is the only match (prev)"
    (is (= (ZonedDateTime/parse "2021-03-28T03:00+02:00[Europe/Brussels]")
           (->
            (c/init {:hour 2}
                    (ZonedDateTime/parse "2021-03-29T02:00+02:00[Europe/Brussels]"))
            c/prev :current))))
  (testing "Return end of gap (2) if hour/minute within gap is the only match (next)"
    (is (= (ZonedDateTime/parse "2021-10-03T02:30+11:00[Australia/Lord_Howe]")
           (->
            (c/init {:minute 10, :hour 2}
                    (ZonedDateTime/of 2021 10 03 1 10 0 0
                                      (ZoneId/of "Australia/Lord_Howe")))
            c/next :current))))
  (testing "Return end of gap (3) if hour/minute within gap is the only match (next)"
    (is (= (ZonedDateTime/parse "2021-10-03T02:30+11:00[Australia/Lord_Howe]")
           (->
            (c/init {:minute 10, :hour 2, :day-of-month [3 10], :month [:* 2 12 2]}
                    (ZonedDateTime/parse "2021-09-02T13:55+10:30[Australia/Lord_Howe]"))
            c/next :current))))
  (testing "Skip day with gap (4) if hour/minute within gap is the only match (prev)"
    (is (= (ZonedDateTime/parse "2021-10-10T02:10+11:00[Australia/Lord_Howe]")
           (->
            (c/init {:minute 10, :hour 2, :day-of-month [3 10], :month [:* 2 12 2]}
                    (ZonedDateTime/parse "2021-11-06T14:25+11:00[Australia/Lord_Howe]"))
            c/prev :current))))
  (testing "Range expansion within enum"
    (is (= nil
           (-> (c/init {:minute 10, :hour 2, :day-of-week [1 3],
                        :week-of-month [:+ [:* 1]]
                        :month [:+ 3 5 9],
                        :week-fields :iso}
                       (ZonedDateTime/parse "2021-09-27T02:10+10:30[Australia/Lord_Howe]"))
               :unaligned?))))
  (testing "Next week stays within current month"
    (is (= (ZonedDateTime/parse "2021-05-31T02:10+10:30[Australia/Lord_Howe]")
           (->
            (c/init {:minute 10, :hour 2, :day-of-week [1 2],
                     :week-of-month [:+ [:* 1]]
                     :month [:+ 3 5 10]
                     :week-fields :iso}
                    (ZonedDateTime/parse "2021-05-25T02:10+10:30[Australia/Lord_Howe]"))
            c/next :current))))
  (testing "Aug 10th is Tue thus not aligned."
    (is (= true
           (-> (c/init {:hour 2,
                        :day-of-week [:+ :thu :sun],
                        :day-of-month [:+ [:* 8 14] [:* -7 -1 1]]}
                       (ZonedDateTime/parse "2021-08-10T02:00+02:00[Europe/Brussels]"))
               :unaligned?))))
  )
